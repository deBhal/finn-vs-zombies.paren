((ps:getprop console 'log) "state.paren: Trident is working as expected")

;; external dependencies
(import (assoc-path
         clone
         drop-last
         filter
         head
         is-empty
         keys
         last
         (map as mapcar)
         merge-all
         min-by
         path
         prop
         reduce
         reject
         tail
         take
         (values as obj-values)
         )
        from *R*)

;;;

;;; In a lispy context, let's not silently ignore all but 2 arguments
(defun merge (&rest args)
  (reduce (@ *R* merge) {} args))

;;; General Utils
(defvar initial-state
  (create :title "Finn vs Zombies"
          :running true
          "time" 0
          "zombieIndex" 1 ; Start at 1 so we can (ab)use falsey 0
          "zombies" (create)
          :plants (create)
          "shots" (create)))

(defun get (&rest prop-path)
  ((path prop-path) *state*))

(defun generate-new-mob-index ()
  (setf (@ *state* zombie-index) (+ 1 (@ *state* zombie-index))))

(defun update! (&rest path-then-value)
  "Change the state. The first n arguments are the path to the data to be updated in the state, and the last argument is the new value to store there."
  (let* ((value (last path-then-value))
         (path (drop-last 1 path-then-value)))
    (setf *STATE* (assoc-path path value *STATE*))
    *STATE*))

(defun constant (key)
  (getprop *STATE* :constants key))

(defun temp-prop (key  &optional duration (target (create)))
  "Returns or updates an object like {plantFooded: {at:2018, duration: 200}} suitable for merging into another object (or setting by key)

  The idea is that code that only cares about the property can just check if it's truthy, but it wraps up enough data to clear out the prop later."
  (setf (getprop target key)
        (merge (create :at (time))
               (create :duration (if (defined duration)
                                     duration
                                     (default-duration key)))))
  target)

(defun is-expired-temp-prop (obj)
  (and obj
       (with-slots (at duration) obj
         (<= (+ at duration) (time)))))

(defun filter-out-expired-temp-props (obj)
  (reject #'is-expired-temp-prop obj))

(defun default-duration (key)
  (or (get 'default-durations key) (get 'default-durations 'default)))

;;; Zombie
(defun randomIntBelow (n)
  (chain +Math (floor (* n ((@ +Math random))))))

(defun plusOrMinus (n)
  (- n (randomIntBelow (+ 1 (* 2 n)))))

(defun spawn-zombie! (&optional (x 1200))
  (let* ((x (if ((@ +Number is-finite) x) x 1200))
         (index (generate-new-mob-index))
         (zombie (create :x x
          :y (plusOrMinus 5)
          :health 10
          :index index)))
    (setf (getprop *state* :zombies index) zombie)
    zombie))

(defun spawn-cone-head! (&optional (x 1200))
  (let ((zombie (spawn-zombie! x)))
    (with-slots (index) zombie
      (update! 'zombies index (merge zombie
                                     (create :cone (create :health 21)))))))

(defun spawn-shot! (&optional (plant (create :x 120 :index 0)))
  (let* ((index (generate-new-mob-index))
         (plant-x (or (and plant (@ plant x)) 0))
         (x (+ plant-x 60)))
    (setf (getprop *state* :shots index)
          (create x x
                  y-jiggle (plusOrMinus 5)
                  shooter-id index
                  index index))))

(defun spawn-plant! (&key x)
  (let* ((x (or x (* 70 (chain (keys (get :plants)) length))))
         (index (generate-new-mob-index)))
    (setf (getprop *state* :plants index)
          (merge default-plant (create x x
                                       index index)))))
(defun time () (@ *STATE* time))

(defun plant-food! (plant)
  (update! :plants (@ plant index)
           (merge plant
                  (temp-prop 'plant-fooded))))

(defun init-zombies ()
  (mapcar spawn-zombie! (list ;0 90 300 600
                               900)))

(defun alivep (zombie)
  (not (or (and (defined (@ zombie health))
                (<= (@ zombie health) 0))
           ;; for now, kill anything that is out of bounds
           (and (defined (@ zombie x))
                (or (<= (@ zombie x) -100)
                    (<= 1300 (@ zombie x))))
           (@ zombie :dead))))

(defun walk (zombie)
  (setf (@ zombie x) (- (@ zombie x) 1))
  zombie
  )

(defun plant-fooded-shot-cooldown ()
  (/ (default-duration 'plant-fooded) (constant 'plant-fooded-shot-count)))

(defun shot-is-cool (plant)
  (with-slots (time-of-last-shot) (merge default-plant plant)
    (let* ((current-time (@ *state* time))
           (time-since-last-shot (- current-time time-of-last-shot))
           (cooldown (if (plant-food-activep plant)
                         (plant-fooded-shot-cooldown)
                         (constant 'plant-shot-cooldown))))
      (or (not time-of-last-shot)
          (<= cooldown time-since-last-shot)))))

(defun plant-food-activep (plant)
  (getprop plant 'plant-fooded))

(defun update-plant (plant)
  (let ((plant (filter-out-expired-temp-props plant)))
    (with-slots (x index time-of-last-shot plant-fooded) (merge default-plant plant)
      (let* ((current-time (@ *state* time))
             (time-since-last-shot (- current-time time-of-last-shot))
             (has-target (not (is-empty (@ *STATE* zombies))))
             (wants-to-shoot (or has-target
                                 plant-fooded))
             (should-shoot (and wants-to-shoot
                                (shot-is-cool plant))))
        (merge-all (list (filter-out-expired-temp-props plant)
                         (create derived (create should-shoot should-shoot
                                                 time-since-last-shot time-since-last-shot
                                                 current-time current-time
                                                 wants-to-shoot wants-to-shoot
                                                 has-target has-target
                                                 ))
                         (and should-shoot
                              (progn
                                (spawn-shot! plant)
                                (create time-of-last-shot current-time)))))))))

(defun update-shot (a-shot)
  (setf (@ a-shot x) (+ (constant 'shot-speed) (@ a-shot x)))
  a-shot)

;;; State
(defun init-state! ()
  ;; I only need this clone because I'm a naughty mutator :p
  (setf *state* (clone initial-state))
  (init-zombies)
  (setf (@ *state* callbacks) (create :spawn-zombie (lambda () (spawn-zombie!))))
  (update! :constants
           (create 'plant-shot-cooldown 150
                   'plant-fooded-shot-count 50
                   shot-speed 4))
  (update! 'default-durations
           (create default 200
                   plant-fooded 100))
  *state*
  )

(defun update-zombie (zombie)
  ;; Sorry mutation
  (setf (@ zombie x) (- (@ zombie x) 0.1))
  ;; Strip armour, not checking the zombie itself
  (filter alivep zombie)
  )

(defun update-zombies ()
  (setf (@ *state* zombies) (mapcar update-zombie (@ *state* zombies)))
  )

(defun pause ()
  (setf (@ *state* running) false)
  ;; Heh. We need an extra render here to render a pause-specific "step" button
  (mrender))

(defun play-pause ()
  (if (@ *state* running) (pause)
      (setf (@ *state* running) true)))

(defun left-most (zombies)
  (let* ((zombies (obj-values zombies)))
    (reduce (min-by (prop :x)) (head zombies) (tail zombies))))

(defun calculate-collisions ()
  (let ((front-zombie (left-most (@ *state* zombies))))
    (if front-zombie (progn
                       (setf (@ *state* front-zombie) front-zombie)
                       (loop for a-shot in (shots)
                          when (<= (@ front-zombie x) (@ a-shot x))
                          collect (create :shot a-shot :zombie front-zombie)))
        (list))))

(defun find-armor (mob)
  "Returns a path to the health that should be decremented e.g. a plant's health, or a zombie's bucket"
  (cond ((@ mob cone) (list 'cone 'health))
        ((@ mob bucket) (list 'bucket 'health))
        (t (list 'health))))

(defun hurt (mob &optional (damage 1))
  "Subtract damage from the mobs health (or bucket)"
  (let* ((health-path (find-armor mob))
         (health (path health-path mob)))
    (assoc-path health-path (- health damage) mob)))

(defun process-collision! (collision)
  (with-slots (shot zombie) collision
    (let* ((zombie-id (@ zombie :index))
           (the-zombie (getprop *state* :zombies zombie-id))
           (shot-id (@ shot :index)))
      (setf (getprop *state* :zombies zombie-id) (hurt the-zombie))
      (setf (getprop *state* :shots shot-id :dead) t))))

(defun process-collisions! ()
  (mapcar process-collision! (@ *state* :collisions))
  )

(defun shots ()
 (obj-values (@ *state* shots)))

(setf #'fitler-dead (filter ((@ *R* negate) (prop :dead))))

(defun tick! ()
  "update all the things"
  (setf (@ *state* time) (+ 1 (@ *state* time)))
  (update-zombies)

  (setf (@ *state* :shots) (mapcar #'update-shot (@ *state* :shots)))
  (setf (@ *state* :plants) (mapcar #'update-plant (@ *state* :plants)))

  (setf (@ *state* :collisions) (calculate-collisions))
  (process-collisions!)

  (setf (@ *state* :shots) (filter alivep (@ *state* :shots)))
  (setf (@ *state* :zombies) (filter alivep (@ *state* :zombies)))
  )
