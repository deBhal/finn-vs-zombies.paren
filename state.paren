((ps:getprop console 'log) "state.paren: Trident is working as expected")

;; external dependencies
(import (assoc-path
         clone
         drop-last
         filter
         head
         is-empty
         keys
         last
         (map as mapcar)
         merge-all
         min-by
         path
         prop
         reduce
         reject
         tail
         take
         (values as obj-values)
         )
        from *R*)

;;; Silently ignoring all but 2 arguments is pretty jarring in a lispy context
(defun merge (&rest args)
  (reduce (@ *R* merge) {} args))

;;; General Utils
(defvar initial-state
  (create :title "Finn vs Zombies"
          :running true
          "time" 0
          "zombieIndex" 1 ; Start at 1 so we can (ab)use falsey 0
          "zombies" (create)
          :plants (create)
          "shots" (create)))

(defun get (&rest prop-path)
  ((path prop-path) *state*))

(defun generate-new-mob-index ()
  (setf (@ *state* zombie-index) (+ 1 (@ *state* zombie-index))))

(defun update! (&rest path-and-value)
  "Change the state"
  (let* ((value (last path-and-value))
         (path (drop-last 1 path-and-value)))
    (setf *STATE* (assoc-path path value *STATE*))
    *STATE*))

(defun constant (key)
  (getprop *STATE* :constants key))

(defun temp-prop (key  &optional duration)
  (let ((result (create)))
    (setf (getprop result key)
          (merge (create :at (time))
                 (create :duration (if (defined duration)
                                       duration
                                       (default-duration key)))))
    result))

(defun is-expired-temp-prop (obj)
  (and obj
       (with-slots (at duration) obj
         (<= (+ at duration) (time)))))

(defun filter-out-expired-temp-props (obj)
  (reject #'is-expired-temp-prop obj))

(defun default-duration (key)
  (or (get 'default-durations key) (get 'default-durations 'default)))

;;; Zombie
(defun randomIntBelow (n)
  (chain +Math (floor (* n ((@ +Math random))))))

(defun plusOrMinus (n)
  (- n (randomIntBelow (+ 1 (* 2 n)))))

(defun create-zombie! (&optional (x 1200))
  (let* ((x (if ((@ +Number is-finite) x) x 1200))
         (index (generate-new-mob-index))
         (zombie (create :x x
          :y (plusOrMinus 5)
          :health 10
          :index index)))
    (setf (getprop *state* :zombies index) zombie)
    zombie))

(defun spawn-shot! (&optional (plant (create :x 120 :index 0)))
  (let* ((index (generate-new-mob-index))
         (plant-x (or (and plant (@ plant x)) 0))
         (x (+ plant-x 60)))
    (setf (getprop *state* :shots index)
          (create x x
                  y-jiggle (plusOrMinus 5)
                  shooter-id index
                  index index))))

(defun spawn-plant! (&key x)
  (let* ((x (or x (* 70 (chain (keys (get :plants)) length))))
         (index (generate-new-mob-index)))
    (setf (getprop *state* :plants index)
          (merge default-plant (create x x
                                       index index)))))
(defun time () (@ *STATE* time))

(defun plant-food! (plant)
  (update! :plants (@ plant index)
           (merge plant
                  (temp-prop 'plant-fooded))))

(defun init-zombies ()
  (mapcar create-zombie! (list ;0 90 300 600
                               900)))

(defun alivep (zombie)
  (not (or
        (<= (@ zombie health) 0)
        ;; for now, kill anything that is out of bounds
        (<= (@ zombie x) -100)
        (<= 1300 (@ zombie x))
        (@ zombie :dead))))

(defun walk (zombie)
  (setf (@ zombie x) (- (@ zombie x) 1))
  zombie
  )

(defun reset-zombie (zombie)
  ((@ +object assign) zombie (create :x 1200 :health 10)))

(setf default-plant (create x 0
                            index 0
                            ;; time-of-last-shot (@ +Number *NEGATIVE_INFINITY*)

                            ))



(defun plant-fooded-shot-cooldown ()
  (/ (default-duration 'plant-fooded) (constant 'plant-fooded-shot-count)))

(defun shot-is-cool (plant)
  (with-slots (time-of-last-shot) (merge default-plant plant)
    (let* ((current-time (@ *state* time))
           (time-since-last-shot (- current-time time-of-last-shot))
           (cooldown (if (plant-food-activep plant)
                         (plant-fooded-shot-cooldown)
                         (constant 'plant-shot-cooldown))))
      (or (not time-of-last-shot)
          (<= cooldown time-since-last-shot)))))

(defun plant-food-activep (plant)
  (getprop plant 'plant-fooded))

(defun update-plant (plant)
  (let ((plant (filter-out-expired-temp-props plant)))
    (with-slots (x index time-of-last-shot plant-fooded) (merge default-plant plant)
      (let* ((current-time (@ *state* time))
             (time-since-last-shot (- current-time time-of-last-shot))
             (has-target (not (is-empty (@ *STATE* zombies))))
             (wants-to-shoot (or has-target
                                 plant-fooded))
             (should-shoot (and wants-to-shoot
                                (shot-is-cool plant))))
        (merge-all (list (filter-out-expired-temp-props plant)
                         (create derived (create should-shoot should-shoot
                                                 time-since-last-shot time-since-last-shot
                                                 current-time current-time
                                                 wants-to-shoot wants-to-shoot
                                                 has-target has-target
                                                 ))
                         (and should-shoot
                              (progn
                                (spawn-shot! plant)
                                (create time-of-last-shot current-time)))))))))

(defun update-shot (a-shot)
  (setf (@ a-shot x) (+ (constant 'shot-speed) (@ a-shot x)))
  a-shot)

(defun update-zombie-hit-by-shot ()
  (setf (@ a-zombie health) (- (@ a-zombie health) 1))
  )

;;; State
(defun init-state! ()
  ;; I only need this clone because I'm a naughty mutator :p
  (setf *state* (clone initial-state))
  (init-zombies)
  (setf (@ *state* callbacks) (create :create-zombie (lambda () (create-zombie!))))
  (update! :constants
           (create 'plant-shot-cooldown 150
                   'plant-fooded-shot-count 50
                   shot-speed 4))
  (update! 'default-durations
           (create default 200
                   plant-fooded 100))
  *state*
  )

(defun update-zombie (zombie)
  ;; Sorry mutation
  (setf (@ zombie x) (- (@ zombie x) 0.1))
  zombie
  )

(defun update-zombies ()
  (setf (@ *state* zombies) (mapcar update-zombie (@ *state* zombies)))
  )

(defun pause ()
  (setf (@ *state* running) false)
  ;; Heh. We need an extra render here to render a pause-specific "step" button
  (mrender))

(defun play-pause ()
  (if (@ *state* running) (pause)
      (setf (@ *state* running) true)))

(defun left-most (zombies)
  (let* ((zombies (obj-values zombies)))
    (reduce (min-by (prop :x)) (head zombies) (tail zombies))))

(defun calculate-collisions ()
  (let ((front-zombie (left-most (@ *state* zombies))))
    (if front-zombie (progn
                       (setf (@ *state* front-zombie) front-zombie)
                       (loop for a-shot in (shots)
                          when (<= (@ front-zombie x) (@ a-shot x))
                          collect (create :shot a-shot :zombie front-zombie)))
        (list))))

(defun process-collision! (collision)
  (with-slots (shot zombie) collision
    (let* ((zombie-id (@ zombie :index))
           (the-zombie (getprop *state* :zombies zombie-id))
           (shot-id (@ shot :index))
           (health (@ the-zombie :health)))
      (setf (getprop *state* :zombies zombie-id :health) (- health 1))
      (setf (getprop *state* :shots shot-id :dead) t))))

(defun process-collisions! ()
  (mapcar process-collision! (@ *state* :collisions))
  )

(defun shots ()
 (obj-values (@ *state* shots)))

(setf #'fitler-dead (filter ((@ *R* negate) (prop :dead))))

(defun tick! ()
  "update all the things"
  (setf (@ *state* time) (+ 1 (@ *state* time)))
  (update-zombies)

  (setf (@ *state* :shots) (mapcar #'update-shot (@ *state* :shots)))
  (setf (@ *state* :plants) (mapcar #'update-plant (@ *state* :plants)))

  (setf (@ *state* :collisions) (calculate-collisions))
  (process-collisions!)

  (setf (@ *state* :shots) (filter alivep (@ *state* :shots)))
  (setf (@ *state* :zombies) (filter alivep (@ *state* :zombies)))
  )
