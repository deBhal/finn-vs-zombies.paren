((ps:getprop console 'log) "state.paren: Trident is working as expected")

;; external dependencies
(import (assoc-path
         drop-last
         head
         is-empty
         last
         (map as mapcar)
         merge
         merge-all
         tail
         take
         )
        from *R*)

(setf min-by (@ *R* min-by))
(setf prop (@ *R* prop))
(setf reduce (@ *R* reduce))
(setf obj-values (@ *R* values))
(import (min-by empty reduce) from *R*)


(defun generate-new-zombie-index ()
  (setf (@ *state* zombie-index) (+ 1 (@ *state* zombie-index))))

(defvar initial-state
  (create :title "Finn vs Zombies"
          :running true
          "time" 0
          "zombieIndex" 1 ; Start at 1 so we can (ab)use falsey 0
          "zombies" (create)
          :plants (create)
          "shots" (create)))


;;; Zombie
(defun randomIntBelow (n)
  (chain +Math (floor (* n ((@ +Math random))))))

(defun plusOrMinus (n)
  (- n (randomIntBelow (+ 1 (* 2 n)))))

(defun create-zombie! (&optional (x 1200))
  (let* ((x (if ((@ +Number is-finite) x) x 1200))
         (index (generate-new-zombie-index))
         (zombie (create :x x
          :y (plusOrMinus 5)
          :health 10
          :index index)))
    (setf (getprop *state* :zombies index) zombie)
    zombie))

(defun spawn-shot! (&optional (plant (create :x 120 :index 0)))
  (let* ((index (generate-new-zombie-index))
         (plant-x (or (and plant (@ plant x)) 120))
         (x (+ plant-x 60)))
    (setf (getprop *state* :shots index)
          (create x x
                  y-jiggle (plusOrMinus 5)
                  shooter-id index
                  index index))))

(defun spawn-plant! (&key (x 120))
  (let* ((index (generate-new-zombie-index)))
    (setf (getprop *state* :plants index)
          (merge default-plant (create x x
                                       index index
                                       )))))
(defun time () (@ *STATE* time))

(defun plant-food! (plant)
  (dump "plant-food-plant" plant)
  (update! :plants (@ plant index)
           (merge plant (create plant-fooded-at (time))))
                                        ;(update )
  )

(defun init-zombies ()
  (mapcar create-zombie! (list ;0 90 300 600
                               900)))


(defun alivep (zombie)
  (not (or
        (<= (@ zombie health) 0)
        ;; for now, kill anything that is out of bounds
        (<= (@ zombie x) -100)
        (<= 1300 (@ zombie x))
        (@ zombie :dead))))

(defun walk (zombie)
  (setf (@ zombie x) (- (@ zombie x) 1))
  zombie
  )

(defun reset-zombie (zombie)
  ((@ +object assign) zombie (create :x 1200 :health 10)))

;;; shot



(setf default-plant (create x 0
                            index 0
                            ;; time-of-last-shot (@ +Number *NEGATIVE_INFINITY*)

                            ))


(defun constant (key)
  (getprop *STATE* :constants key))

(update! :constants
         (create 'plant-shot-cooldown 500
                 'plant-fooded-shot-cooldown 5
                 'plant-fooded-shot-count 50
                 shot-speed 1))



(defun update! (&rest path-and-value)
  "Change the state"
  (let* ((value (last path-and-value))
         (path (drop-last 1 path-and-value)))
    (setf *STATE* (assoc-path path value *STATE*))
    *STATE*))
(update! :title "Foobar")
(setf path-and-value '(title "Foo"))
(setf value (last path-and-value))
(setf path (drop-last 1 path-and-value))

(defun shot-is-cool (plant)
  (with-slots (time-of-last-shot) (merge default-plant plant)
    (let* ((current-time (@ *state* time))
           (time-since-last-shot (- current-time time-of-last-shot))
           (cooldown (if (plant-food-activep plant)
                         (constant 'plant-fooded-shot-cooldown)
                         (constant 'plant-shot-cooldown))))
      (or (not time-of-last-shot)
          (<= cooldown time-since-last-shot)))))


(defun plant-food-activep (plant)
  (with-slots (plant-fooded-at) plant
    (dump "plant-fooded-at" plant-fooded-at)
    (and plant-fooded-at
         (<= (time) (+ plant-fooded-at (* (constant 'plant-fooded-shot-count)
                                          (constant 'plant-fooded-shot-cooldown))
                       )))))

(defun update-plant (plant)
  (with-slots (x index time-of-last-shot plant-fooded-at) (merge default-plant plant)
    (let* ((current-time (@ *state* time))
           (time-since-last-shot (- current-time time-of-last-shot))
           (should-shoot (and (shot-is-cool plant)
                              (or (not (is-empty (@ *STATE* zombies)))
                                  (plant-food-activep plant))))
           (plant-food-active (plant-food-activep plant)))
      (merge-all (list plant
                      (create should-shoot should-shoot
                              time-since-last-shot time-since-last-shot
                              current-time current-time
                              plant-food-active plant-food-active)
                      (and should-shoot
                           (progn
                             (spawn-shot! plant)
                             (create time-of-last-shot current-time
                                     ))))))))

(defun update-shot (a-shot)
  (setf (@ a-shot x) (+ *shot-speed* (@ a-shot x)))
  a-shot)

(defun update-zombie-hit-by-shot ()
  (setf (@ a-zombie health) (- (@ a-zombie health) 1))
  )

;; I only need this because I'm a naughty mutator :'(
(setf clone (@ *R* clone))
;;; State
(defun init-state! ()
  (setf *state* (clone initial-state))

  (init-zombie)
  (init-zombies)
  (setf (@ *state* callbacks) (create :create-zombie (lambda () (create-zombie!))))
  *state*
  )

(defun update-zombie (zombie)
  ;; Sorry mutation
  (setf (@ zombie x) (- (@ zombie x) 0.1))
  zombie
  )

(defun update-zombies ()
  (setf (@ *state* zombies) (mapcar update-zombie (@ *state* zombies)))
  )

(defun play-pause ()
  (setf (@ *state* running) (not (@ *state* running)))
  ;; Heh. We need an extra render here to render a pause-specific "step" button
  (mrender)
  )

(init-state!)


(defun left-most (zombies)
  (let* ((zombies (obj-values zombies)))
    (reduce (min-by (prop :x)) (head zombies) (tail zombies))))

(defun calculate-collisions ()
  (let ((front-zombie (left-most (@ *state* zombies))))
    (if front-zombie (progn
                       (setf (@ *state* front-zombie) front-zombie)
                       (loop for a-shot in (shots)
                          when (<= (@ front-zombie x) (@ a-shot x))
                          collect (create :shot a-shot :zombie front-zombie)))
        (list))))

(defun process-collision! (collision)
  (with-slots (shot zombie) collision
    (let* ((zombie-id (@ zombie :index))
           (the-zombie (getprop *state* :zombies zombie-id))
           (shot-id (@ shot :index))
           (health (@ the-zombie :health)))
      (setf (getprop *state* :zombies zombie-id :health) (- health 1))
      (setf (getprop *state* :shots shot-id :dead) t))))

(defun process-collisions! ()
  (mapcar process-collision! (@ *state* :collisions))
  )

(defun shots ()
 (obj-values (@ *state* shots)))

(setf #'filter (@ *R* filter))
(setf #'fitler-dead (filter ((@ *R* negate) (prop :dead))))
(setf #'prop (@ *R* prop))

(defun tick! ()
  "update all the things"
  (setf (@ *state* time) (+ 1 (@ *state* time)))
  (update-zombies)

  (setf (@ *state* :shots) ((@ *R* map) #'update-shot (@ *state* :shots)))
  (setf (@ *state* :plants) ((@ *R* map) #'update-plant (@ *state* :plants)))

  (setf (@ *state* :collisions) (calculate-collisions))
  (process-collisions!)

  (setf (@ *state* :shots) (filter alivep (@ *state* :shots)))
  (setf (@ *state* :zombies) (filter alivep (@ *state* :zombies)))

  )

(tick!)

; UI Glue, depends on react-app.paren
(defun main-loop ()
  (try
   (and (@ *state* running)
        (progn
          (tick!)
          (and (defined render) (render))
          (and (defined mrender) (mrender))))
   (:finally (request-animation-frame #'main-loop))))

(main-loop)

(defun step ()
  (tick!)
  (mrender))
