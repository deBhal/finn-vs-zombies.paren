((ps:getprop console 'log) "state.paren: Trident is working as expected")

;; external dependencies
(setf mapcar (@ *R* map))

(defun generate-new-zombie-index ()
  (setf (@ *state* zombie-index) (+ 1 (@ *state* zombie-index))))

(defvar initial-state
  (create :title "Finn vs Zombies"
          :running true
          "time" 0
          "zombieIndex" 0
          "zombies" (create)
          "shots" (create)))

(defvar *shot-speed* 10)

;;; Zombie
(defun randomIntBelow (n)
  (chain +Math (floor (* n ((@ +Math random))))))

(defun plusOrMinus (n)
  (- n (randomIntBelow (+ 1 (* 2 n)))))

(defun create-zombie! (&optional (x 1200))
  (let* ((x (if ((@ +Number is-finite) x) x 1200))
         (index (generate-new-zombie-index))
         (zombie (create :x x
          :y (plusOrMinus 5)
          :health 10
          :index index)))
    (setf (getprop *state* :zombies index) zombie)
    zombie))

(defun spawn-shot! (&optional (plant-id 0))
  (let* ((index (generate-new-zombie-index))
         (x 120))
    (setf (getprop *state* :shots index)
          (create x x
                  y-jiggle (plusOrMinus 5)
                  shooter-id plant-id
                  index index))))

(defun init-zombie ()
  ;(setf a-zombie (create-zombie))
  )

(defun init-zombies ()
  (mapcar create-zombie! (list ;0 90 300 600
                               900)))


(defun alivep (zombie)
  (not (or
        (<= (@ zombie health) 0)
        ;; for now, kill anything that is out of bounds
        (<= (@ zombie x) -100)
        (<= 1300 (@ zombie x))
        (@ zombie :dead))))

(defun walk (zombie)
  (setf (@ zombie x) (- (@ zombie x) 1))
  zombie
  )

(defun reset-zombie (zombie)
  ((@ +object assign) zombie (create :x 1200 :health 10)))

;;; shot

(defun create-shot (plant)
  (let ((x 70)
        (y 55))
    (create :x x :y y))
  )


(defun update-shot (a-shot)
  (setf (@ a-shot x) (+ *shot-speed* (@ a-shot x)))
  a-shot)


(defun reset-shot ()
  (setf a-shot (create-shot)))

(defun update-zombie-hit-by-shot ()
  (setf (@ a-zombie health) (- (@ a-zombie health) 1))
  )

;; I only need this because I'm a naughty mutator :'(
(setf clone (@ *R* clone))
;;; State
(defun init-state! ()
  (setf *state* (clone initial-state))

  (init-zombie)
  (init-zombies)
  (setf (@ *state* callbacks) (create :create-zombie (lambda () (create-zombie!))))
  *state*
  )

(defun update-zombie (zombie)
  ;; Sorry mutation
  (setf (@ zombie x) (- (@ zombie x) 1))
  zombie
  )

(defun update-zombies ()
  (setf (@ *state* zombies) (mapcar update-zombie (@ *state* zombies)))
  )

(defun play-pause ()
  (setf (@ *state* running) (not (@ *state* running)))
  ;; Heh. We need an extra render here to render a pause-specific "step" button
  (mrender)
  )

(init-state!)

(setf min-by (@ *R* min-by))
(setf prop (@ *R* prop))
(setf reduce (@ *R* reduce))
(setf obj-values (@ *R* values))

(defun left-most (zombies)
  (reduce (min-by (prop :x)) (create :x +infinity) (obj-values zombies)))

(defun calculate-collisions ()
  (let ((front-zombie (left-most (@ *state* zombies))))
    (and front-zombie
         (progn
           (setf (@ *state* front-zombie) front-zombie)
           (loop for a-shot in (shots)
              when (<= (@ front-zombie x) (@ a-shot x))
              collect (create :shot a-shot :zombie front-zombie))))))

(defun process-collision! (collision)
  (with-slots (shot zombie) collision
    (let* ((zombie-id (@ zombie :index))
           (the-zombie (getprop *state* :zombies zombie-id))
           (shot-id (@ shot :index))
           (health (@ the-zombie :health)))
      (setf (getprop *state* :zombies zombie-id :health) (- health 1))
      (setf (getprop *state* :shots shot-id :dead) t))))

(defun process-collisions! ()
  (mapcar process-collision! (@ *state* :collisions))
  )

(defun shots ()
 (obj-values (@ *state* shots)))

(setf #'filter (@ *R* filter))
(setf #'fitler-dead (filter ((@ *R* negate) (prop :dead))))
(setf #'prop (@ *R* prop))

(defun tick! ()
  "update all the things"
  (setf (@ *state* time) (+ 1 (@ *state* time)))
  (update-zombies)

  (setf (@ *state* :shots) ((@ *R* map) #'update-shot (@ *state* :shots)))

  (setf (@ *state* :collisions) (calculate-collisions))
  (process-collisions!)

  (setf (@ *state* :shots) (filter alivep (@ *state* :shots)))
  (setf (@ *state* :zombies) (filter alivep (@ *state* :zombies)))

  )

(tick!)

; UI Glue, depends on react-app.paren
(defun main-loop ()
  (try
   (and (@ *state* running)
        (progn
          (tick!)
          (and (defined render) (render))
          (and (defined mrender) (mrender))))
   (:finally (request-animation-frame #'main-loop))))

(main-loop)

(defun step ()
  (tick!)
  (mrender))
